How to support interactive test case creation.
**********************************************

Requirements
------------
To effectively this feature into a SDK in your own language and framework, you need the ability to make HTTP POST requests, take screenshots and extract bounding boxes from the elements that you want to learn.

Conceptual overview
--------------------
A neat feature of the official Python SDK that you can replicate yourself is the ability to create a test case live. If you have checked the documentation and looked at the interactive video you have an idea of how that works. In short the developer will write a test case comprised only of find_by_element_name so that all the elements they want to interact with have a label, then as they execute the test case, they will be prompted to go into the UI and add a bounding box for each element.

To support this use case, we only need the two functions:
 - :func:`api.v1.backend.test_case_upload`
 - :func:`api.v1.backend.test_case_get_box`

What we recommend is to trigger the test case creation by passing a flag or env variable to the script.

.. code-block:: python

    def process_element_name(element_name, test_case_uuid):
        import os
        test_case_uuid = 'my_test_case'
        element_name = 'my_element'

        if strtobool(os.environ.get('TESTAI_INTERACTIVE', '0')) == 1:
            test_case_upload_screenshot(b64encode(driver.take_screenshot()), element_name)
            bounding_box = test_case_get_box(element_name)
            if bounding_box is not None:
                return bounding_box
            else:
                url = 'https://sdk.test.ai/test_case/label/' + urllib.parse.quote(self.test_case_uuid)
                print(f'No bounding box for {element_name}, please visit {url} to label it')
                webbrowser.open(url)
                while True:
                    # We enter the interative loop waiting for user to label
                    bounding_box = test_case_get_box(element_name)
                    if bounding_box is not None:
                        return bounding_box
                    time.sleep(1)
..

As you can see the code tries to find a bounding box for the element and keeps waiting until the user enters one.
